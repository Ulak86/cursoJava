
# BBDD
## Modos típicos de incluir datos auditables en tablas SQL Oracle

> [!CAUTION]  El profesor solo nombro que había métodos típicos para ello, pero no lo explicó.

En entornos donde es importante mantener trazabilidad (por ejemplo, saber quién creó o modificó un dato, y cuándo), se suele implementar auditoría directamente en las tablas o mediante estructuras adicionales. A continuación, se detallan las opciones más comunes.

---

### 1. Campos de auditoría en cada tabla

Consiste en agregar columnas de control directamente en las tablas principales de datos.

**Campos comunes:**

| Campo        | Descripción                                       |
| ------------ | ------------------------------------------------- |
| `CREATED_AT` | Fecha y hora de creación del registro             |
| `CREATED_BY` | Usuario que creó el registro                      |
| `UPDATED_AT` | Fecha y hora de la última modificación            |
| `UPDATED_BY` | Usuario que hizo la última modificación           |
| `DELETED_AT` | Fecha de eliminación lógica (opcional)            |
| `DELETED_BY` | Usuario que eliminó lógicamente (opcional)        |
| `IS_DELETED` | Bandera para marcar eliminación lógica (opcional) |

**Ventajas:**

- Fácil de implementar
    
- Accesible directamente desde las consultas normales
    
- Compatible con frameworks ORM
    

**Desventajas:**

- Solo registra la última acción
    
- No guarda historial detallado de cambios
    

---

### 2. Tablas de auditoría o histórico (Change Log)

Se crean tablas separadas, normalmente con el mismo diseño que la tabla original, más campos adicionales para el seguimiento de acciones.

**Campos adicionales comunes:**

- `AUDIT_ACTION` (INSERT, UPDATE, DELETE)
    
- `AUDIT_TIMESTAMP`
    
- `AUDIT_USER`
    
- `AUDIT_SESSION_ID`
    
- Otros metadatos relevantes
    

**Implementación típica:**

- Triggers en la tabla principal que insertan en la tabla de auditoría ante cada cambio
    
- También puede hacerse desde la lógica de negocio en la aplicación
    

**Ventajas:**

- Permite guardar todo el historial de cambios
    
- Útil para auditorías y trazabilidad detallada
    

**Desventajas:**

- Requiere más espacio en disco
    
- Mayor complejidad en mantenimiento y consultas
    

---

### 3. Uso de Triggers

Los triggers permiten automatizar la actualización de campos de auditoría o la inserción en tablas de auditoría.

**Ejemplo 1: Actualizar campos de auditoría en la tabla original**

```SQL
CREATE OR REPLACE TRIGGER trg_before_update_cliente
BEFORE UPDATE ON clientes
FOR EACH ROW
BEGIN
  :NEW.updated_at := SYSDATE;
  :NEW.updated_by := SYS_CONTEXT('USERENV', 'SESSION_USER');
END;
```

**Ejemplo 2: Insertar en tabla de auditoría**

```SQL
CREATE OR REPLACE TRIGGER trg_audit_cliente
AFTER INSERT OR UPDATE OR DELETE ON clientes
FOR EACH ROW
BEGIN
  INSERT INTO clientes_aud (
    id, nombre, email, audit_action, audit_timestamp, audit_user
  ) VALUES (
    COALESCE(:OLD.id, :NEW.id),
    COALESCE(:OLD.nombre, :NEW.nombre),
    COALESCE(:OLD.email, :NEW.email),
    CASE
      WHEN INSERTING THEN 'INSERT'
      WHEN UPDATING THEN 'UPDATE'
      WHEN DELETING THEN 'DELETE'
    END,
    SYSDATE,
    SYS_CONTEXT('USERENV', 'SESSION_USER')
  );
END;
```

---

### 4. Uso de ORA_ROWSCN y Flashback

Oracle permite utilizar funciones internas para ver versiones anteriores de registros o identificar cuándo fue la última modificación.

- `ORA_ROWSCN`: Pseudocolumna que indica el SCN (System Change Number) de la última modificación
    
- Flashback Query: Permite consultar cómo estaba una tabla en un momento pasado, si el UNDO lo permite
    

**Ventajas:**

- No requiere cambiar las tablas
    
- Útil para recuperación y análisis temporal
    

**Desventajas:**

- Requiere configuración avanzada
    
- Limitado por la retención de UNDO
    

---

### 5. Auditoría nativa de Oracle (DB-level)

Oracle ofrece mecanismos de auditoría avanzados a nivel de base de datos:

- **Standard Auditing**
    
- **Fine-Grained Auditing (FGA)**
    
- **Oracle Audit Vault**
    

**Ventajas:**

- No requiere modificar tablas de negocio
    
- Cumple normativas exigentes (por ejemplo, seguridad financiera o sanitaria)
    

**Desventajas:**

- Puede requerir licencias adicionales
    
- Configuración y monitoreo más complejos
    

---

### Recomendación práctica habitual

En la mayoría de proyectos empresariales se recomienda:

1. Agregar campos de auditoría (`created_at`, `updated_at`, etc.) en cada tabla
    
2. Si se requiere historial completo, usar triggers y una tabla de auditoría asociada
    
3. Para entornos con requerimientos regulatorios altos, considerar Flashback o herramientas de auditoría de Oracle
    

---

## `ROUND`

Se utiliza para redondear números o fechas. Aquí tienes la sintaxis y ejemplos claros, todos envueltos con el formato que necesitas para Obsidian:

---

### 1. Redondeo de Números

### Sintaxis:

```SQL
ROUND(número [, decimales])
```

- `número`: valor numérico que deseas redondear.
    
- `decimales`: número de decimales a los que quieres redondear (opcional). Si se omite, redondea al entero más cercano.
    

### Ejemplos:

```SQL
-- Redondea a 2 decimales
SELECT ROUND(123.4567, 2) AS resultado FROM dual;
-- Resultado: 123.46

-- Redondea a 0 decimales (entero más cercano)
SELECT ROUND(123.5) AS resultado FROM dual;
-- Resultado: 124

-- Redondea a -1 (decena más cercana)
SELECT ROUND(123.4567, -1) AS resultado FROM dual;
-- Resultado: 120
```


---

### 2. Redondeo de Fechas

Cuando se usa con fechas, `ROUND` redondea al período más cercano según la unidad indicada.

### Sintaxis:

```SQL
ROUND(fecha, 'unidad')
```

- `fecha`: valor de tipo `DATE`
    
- `unidad`: puede ser `'YEAR'`, `'MONTH'`, `'DAY'`, etc.
    

#### Ejemplos:

```SQL
-- Redondea al primer día del mes más cercano
SELECT ROUND(TO_DATE('15-SEP-2023', 'DD-MON-YYYY'), 'MONTH') AS resultado FROM dual;
-- Resultado: 01-OCT-2023

-- Redondea al domingo o lunes más cercano según NLS_TERRITORY
SELECT ROUND(TO_DATE('04-OCT-2023', 'DD-MON-YYYY'), 'W') AS resultado FROM dual;
```


---

## Debezium

> [!CAUTION]  El profesor solo lo nombró, pero no lo explicó.
### ¿Qué es Debezium?

Debezium es una plataforma open-source que escucha los logs de transacciones de bases de datos (como MySQL, PostgreSQL, SQL Server, Oracle, MongoDB) y transmite esos cambios a **Kafka topics**, permitiendo construir aplicaciones _event-driven_ basadas en los cambios en las bases de datos.

---

### Arquitectura básica

`[Base de datos] -> [Debezium Connector] -> [Kafka Topic] -> [Consumer]`

1. La base de datos produce cambios (INSERT, UPDATE, DELETE).
    
2. Debezium lee el log de transacciones (binlog, WAL, etc.).
    
3. Esos cambios se publican como eventos en Kafka.
    
4. Tus servicios pueden consumir esos eventos desde Kafka.
    

---

### Requisitos generales

- Apache Kafka en ejecución
    
- Apache Kafka Connect (puede usar el de Confluent o standalone)
    
- Debezium Connector (MySQL, PostgreSQL, SQL Server, Oracle, MongoDB, etc.)
    
- Base de datos configurada para permitir CDC (según el tipo)