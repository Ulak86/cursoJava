## Continuación Maven

El archivo de Maven configuración, una vez un proyecto se configura como Maven, controla la configuración de todo el proyecto.

Como demostración, hemos editado esta línea

```xml
<release>21</release>
```

a

```xml
<release>17</release>
```

y la carpeta de proyecto ha pasado de indicar que el proyecto era JavaSE-21 a JavaSE-17 

**Logback** es un framework de **logging (registro de logs)** para aplicaciones Java. Es uno de los más usados en la actualidad y se considera el **sucesor de log4j**, creado por el mismo autor (Ceki Gülcü). Forma parte de la familia de herramientas de **SLF4J**.

Libro que recomienda el profesor sobre logs: [I Heart Logs](https://www.oreilly.com/library/view/i-heart-logs/9781491909379/)

**Kibana** Logs es una herramienta de visualizacion de logs. 

**Elasticsearch** es un **motor de búsqueda y análisis de datos** basado en **Lucene**, de código abierto (aunque algunas versiones son bajo licencia propietaria), diseñado para trabajar con grandes volúmenes de datos en tiempo real que se usa en analisis de logs.

Hemos creado una carpeta en el proyecto asi: 
1. Boton dcho sobre el proyecto > New > Source Folder y la hemos llamado resources
2. Hemos copiado su archivo logback.xml que estaba en su carpeta resources a la nuestra que hemos creado en el paso 1.

Ahora hemos vuelto a la clase HolaMundo sobre la que estabamos trabajando ayer, hemos eliminado sus imports, y hemos importado este Interfaz (ya explicara interfaces) a la clase:

import org.slf4j.Logger;

```java
private final static Logger log = LoggerFactory.getLogger(HolaMundo.class);
```

Esta línea declara un logger estático y final llamado `log`, usando SLF4J para la clase `HolaMundo`. Permite registrar mensajes de log identificándolos con esa clase. Se usa para imprimir mensajes de distintos niveles (info, debug, error, etc.) en la aplicación.

Hemos añadido esta linea

```java
log.info("Hola");
```

Que resulta en esto por la consola:
2025-09-16 17:10:31 INFO [main] HolaMundo - Hola

```java
log.debug("Adios");
```

Y hemos visto que en la configuracion logback.xml esta en el nivel debug.

- `info()`, `debug()`, `error()`, `warn()`... son métodos de la interfaz `org.slf4j.Logger`.
    
- Logback es una implementación que recibe esas llamadas y realiza el logging según la configuración.

Los niveles son lo siguientes:

ERROR
WARN
->INFO
DEBUG
TRACE

Esto:

```java
log.info("Hola");
log.debug("Adios");
log.warn("Adios");
log.trace("Adios");
```

Da lugar a esto en la consola:

```console
2025-09-16 17:20:06 INFO [main] HolaMundo - Hola
2025-09-16 17:20:06 WARN [main] HolaMundo - Adios
```

Porque la configuracion de **logback** en logback.xml define este nivel por defecto:

```xml
	<!-- Nivel por defecto -->
	<root level="info">
		<appender-ref ref="STDOUT"/>
		<appender-ref ref="FILE"/>
	</root>
</configuration>
```

Entonces, por consola, solo mostrara los niveles desde info hacia arriba

También, por lo configurado en logback.xml, registrara en el archivo app.log que crea en el proyecto los mismos logs que muestra por consola.

## Herencia

Veremos las clases padres, de las cuales heredan las hijas todos los atributos y métodos **no privados**.

La herencia en Java es única, una clase hija solo puede heredar de una clase padre. Pero esta clase padre puede a su vez heredar de otro padre.

En Java, todas las clases heredan de Object.

Para superar la limitación de Java en la que solo se puede heredar de un padre, se introdujeron los Interfaces.

Si los atributos de la clase padre son private, la hija necesitara hacer uso de metodos publicos de esa clase para poder acceder a ellos.

Para declarar que una clase hereda de otra, usamos la palabra **extend**. Ejemplo:

```java
public class Vaca extends Animal
```

Todos los objectos en Java son un object.

El profesor dio una explicación de la herencia de constructores que me costó seguir. Las clases hijas heredan los constructores y a la vez todas las clases heredan de la clase Object. Hizo las clases de animales para explicarlo.

Puedo crear también una vaca así:

```java
Animal animal = new Vaca(...,...);
```

Siempre fijarse en el new para ver que estamos instanciando.

En un constructor, el super es implicito.