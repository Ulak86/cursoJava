# PPOO

## Colecciones - Genericos

### Genéricos

Todas las colecciones permiten el uso de genéricos, lo que:

- **Evita conversiones (casting)** innecesarias.
    
- **Previene errores en tiempo de compilación** (al tratar de agregar elementos de tipos no esperados).
    
- **Mejora la legibilidad** y mantenibilidad del código.

---

## Colecciones - Clases

En el **Java Collections Framework**, las **clases adquieren funcionalidades** a través de las **interfaces que implementan**. Este es un principio fundamental de la programación orientada a objetos en Java: **las interfaces definen el "qué" se puede hacer, y las clases definen el "cómo" se hace.**

---

## `Iterable<T>`

La interfaz `Iterable<T>` es parte del paquete `java.util` y es la superinterfaz de todas las colecciones en Java (`List`, `Set`, `Queue`, etc.). Representa una colección cuyos elementos pueden ser recorridos secuencialmente.

### Métodos de `Iterable<T>`

```java
public interface Iterable<T> { 
    Iterator<T> iterator(); // Java 5 
    default void forEach(Consumer<? super T> action); // Java 8 
    default Spliterator<T> spliterator(); // Java 8 
}
```


### Descripción de los métodos

|Método|Desde|Descripción|
|---|---|---|
|`Iterator<T> iterator()`|Java 5|Devuelve un iterador para recorrer los elementos de la colección.|
|`void forEach(Consumer<? super T>)`|Java 8|Ejecuta una acción sobre cada elemento usando programación funcional.|
|`Spliterator<T> spliterator()`|Java 8|Devuelve un spliterator para procesamiento secuencial o paralelo.|

### Ejemplo de uso con `for-each`

```java
List<String> nombres = Arrays.asList("Ana", "Luis", "Marta");  
for (String nombre : nombres) {     
    System.out.println(nombre); 
}
```

### Ejemplo con `forEach` y lambda

```java
nombres.forEach(n -> System.out.println("Hola, " + n));
```

### Uso directo del `Iterator`

```java
Iterator<String> it = nombres.iterator(); 
while (it.hasNext()) {     
    System.out.println(it.next()); 
}
```

### Notas

- Todas las colecciones del Java Collections Framework implementan `Iterable`.
    
- Permite el uso del bucle `for-each`.
    
- Desde Java 8, admite programación funcional con `forEach` y procesamiento paralelo con `spliterator`.

---

## `Collection<E>`

La interfaz `Collection<E>` forma parte del paquete `java.util` y es la raíz de la jerarquía de colecciones en Java, excluyendo los mapas (`Map`). Todas las colecciones como `List`, `Set`, `Queue` heredan de esta interfaz, que define operaciones básicas sobre grupos de elementos.

### Métodos clave de `Collection<E>`

```java
public interface Collection<E> extends Iterable<E> {     
    int size();     
    boolean isEmpty();     
    boolean contains(Object o);     
    Iterator<E> iterator();     
    Object[] toArray();     
    <T> T[] toArray(T[] a);     
    boolean add(E e);     
    boolean remove(Object o);     
    boolean containsAll(Collection<?> c);     
    boolean addAll(Collection<? extends E> c);     
    boolean removeAll(Collection<?> c);     
    boolean retainAll(Collection<?> c);     
    void clear();      

    // Métodos por defecto desde Java 8     
    boolean removeIf(Predicate<? super E> filter);     
    Spliterator<E> spliterator();     
    Stream<E> stream();     
    Stream<E> parallelStream();     
    void forEach(Consumer<? super E> action); 
}
```

### Descripción de métodos comunes

|Método|Descripción|
|---|---|
|`size()`|Devuelve el número de elementos en la colección.|
|`isEmpty()`|Verifica si la colección está vacía.|
|`contains(Object o)`|Verifica si un elemento está presente.|
|`add(E e)`|Agrega un elemento a la colección.|
|`remove(Object o)`|Elimina una instancia del elemento si existe.|
|`clear()`|Elimina todos los elementos.|
|`toArray()`|Devuelve un array de `Object` con los elementos de la colección.|
|`toArray(T[] a)`|Devuelve un array del tipo específico `T[]` con los elementos.|
|`addAll(Collection<? extends E>)`|Agrega todos los elementos de otra colección.|
|`removeAll(Collection<?>)`|Elimina de esta colección todos los elementos que también están en otra.|
|`retainAll(Collection<?>)`|Conserva solo los elementos que están también en otra colección.|

### Métodos por defecto (Java 8+)

|Método|Descripción|
|---|---|
|`forEach(Consumer<? super E>)`|Aplica una acción a cada elemento.|
|`removeIf(Predicate<? super E>)`|Elimina elementos que cumplen una condición.|
|`stream()`|Devuelve un `Stream` secuencial.|
|`parallelStream()`|Devuelve un `Stream` paralelo.|
|`spliterator()`|Devuelve un `Spliterator` para procesamiento eficiente.|

### Ejemplo de uso

```java
Collection<String> palabras = new ArrayList<>(); 
palabras.add("uno"); 
palabras.add("dos");  

if (palabras.contains("uno")) {     
    System.out.println("Contiene 'uno'"); 
}  

String[] array = palabras.toArray(new String[0]); // Array de tipo específico
```

### Notas

- Todas las interfaces como `List`, `Set`, `Queue` extienden `Collection`.
    
- `Collection` extiende `Iterable`, por lo que admite `for-each`.
    
- La mayoría de las implementaciones permiten elementos duplicados, excepto `Set`.

---

## `List<E>`

La interfaz `List<E>`, parte del paquete `java.util`, extiende `Collection<E>` y representa una **colección ordenada** que puede contener elementos duplicados. Los elementos tienen una posición (índice), lo que permite acceso, inserción y eliminación basada en la posición.

Las implementaciones comunes incluyen `ArrayList`, `LinkedList` y `Vector`.

### Métodos clave de `List<E>`

```java
public interface List<E> extends Collection<E> {     
    void add(int index, E element);     
    boolean addAll(int index, Collection<? extends E> c);     
    E get(int index);     
    E set(int index, E element);     
    E remove(int index);     
    int indexOf(Object o);     
    int lastIndexOf(Object o);     
    ListIterator<E> listIterator();     
    ListIterator<E> listIterator(int index);     
    List<E> subList(int fromIndex, int toIndex); 
}
```

### Descripción de métodos comunes

|Método|Descripción|
|---|---|
|`add(int index, E element)`|Inserta un elemento en una posición específica.|
|`addAll(int index, Collection<?>)`|Inserta todos los elementos de otra colección a partir del índice dado.|
|`get(int index)`|Devuelve el elemento en la posición especificada.|
|`set(int index, E element)`|Reemplaza el elemento en la posición especificada.|
|`remove(int index)`|Elimina el elemento en la posición especificada.|
|`indexOf(Object o)`|Devuelve el índice de la primera ocurrencia del elemento.|
|`lastIndexOf(Object o)`|Devuelve el índice de la última ocurrencia del elemento.|
|`listIterator()`|Devuelve un `ListIterator` para recorrer la lista (avance y retroceso).|
|`listIterator(int index)`|Igual que el anterior, pero comenzando desde un índice específico.|
|`subList(int fromIndex, int toIndex)`|Devuelve una vista de parte de la lista (exclusivo `toIndex`).|

### Ejemplo de uso

```java
List<String> nombres = new ArrayList<>(); 
nombres.add("Ana"); 
nombres.add("Luis"); 
nombres.add("Marta");  

nombres.add(1, "Carlos"); // Inserta "Carlos" en la posición 1  

System.out.println(nombres.get(2)); // "Luis"  

nombres.remove(0); // Elimina "Ana"  

List<String> sublista = nombres.subList(0, 2); // Vista parcial de la lista
```

### Notas

- Permite elementos **duplicados**.
    
- Mantiene el **orden de inserción**.
    
- Soporta acceso y modificación por índice.
    
- Es una de las colecciones más utilizadas debido a su versatilidad.

---

## `final class` y herencia

En Java, el modificador `final` aplicado a una clase indica que no puede ser extendida. Es decir, una clase `final` no permite herencia.

Esto se utiliza principalmente para garantizar que la implementación de la clase no pueda ser alterada por medio de subclases, lo que es útil por motivos de seguridad, diseño o eficiencia.

Las clases `final` no pueden ser subclasificadas, pero sus instancias pueden usarse libremente como campos o variables.
### Sintaxis

```java
public final class MiClaseFinal {     
    // código 
}
```

### Consecuencias del uso de `final` en clases

- No se puede extender (heredar) la clase.
    
- Se puede instanciar la clase normalmente.
    
- Se puede usar como atributo, parámetro o tipo de retorno.
    

### Ejemplo

```java
final class Animal {     
    void hablar() {         
        System.out.println("Sonido genérico");     
    } 
}  

// Esto provocará un error de compilación: 
// class Perro extends Animal { } 
// Error: Cannot subclass final class
```

### Uso común: clases `final` en Java

Muchas clases del JDK son `final` para evitar su extensión y mantener su comportamiento inalterado.

Ejemplos:

```java
public final class String { ... } 
public final class Integer { ... } 
public final class Math { ... }
```

### Relación con herencia

|Característica|¿Permitida en `final class`?|
|---|---|
|Heredar de la clase|No|
|Instanciar la clase|Sí|
|Usar como tipo genérico|Sí|
|Sobrescribir métodos|No se pueden heredar métodos|

### Comparación con `final` en otros contextos

|Uso de `final`|Efecto|
|---|---|
|`final class`|No se puede heredar la clase.|
|`final method`|No se puede sobrescribir el método en subclases.|
|`final variable`|La variable no puede cambiar de valor una vez asignada.|
|`final parameter`|El parámetro no puede ser modificado dentro del método.|

---

### Notas

- Usar `final` en clases puede ayudar a diseñar clases inmutables.
    
- También puede ser una forma de evitar un uso indebido de la herencia.
    
- Una clase `final` **no puede ser abstracta**, porque `final` impide herencia y `abstract` requiere que la clase sea extendida.
    
- Si deseas diseñar una clase que permita herencia, simplemente no uses `final`

---

## Añadir múltiples referencias al mismo objeto en una `List` usando un bucle `for`

```java
class Persona {
    String nombre;

    Persona(String nombre) {
        this.nombre = nombre;
    }
}

public class Ejemplo {
    public static void main(String[] args) {
        Persona p = new Persona("Juan");
        List<Persona> lista = new ArrayList<>();

        for (int i = 0; i < 10000; i++) {
            lista.add(p);
        }

        System.out.println("Tamaño de la lista: " + lista.size()); // Debería imprimir 10000
        System.out.println("Primer elemento: " + lista.get(0).nombre); // Juan
    }
}
```

---
## Añadir múltiples objetos distintos en una `List` usando un bucle `for`

```java
import java.util.ArrayList;
import java.util.List;

class Persona {
    String nombre;

    Persona(String nombre) {
        this.nombre = nombre;
    }
}

public class Ejemplo {
    public static void main(String[] args) {
        List<Persona> lista = new ArrayList<>();

        for (int i = 0; i < 10000; i++) {
            lista.add(new Persona(i + "A"));
        }

        System.out.println("Tamaño de la lista: " + lista.size()); // 10000
        System.out.println("Primer elemento: " + lista.get(0).nombre); // "0A"
        System.out.println("Último elemento: " + lista.get(9999).nombre); // "9999A"
    }
}
```

---

## Métodos `add` en `List<E>`

La interfaz `List<E>` define métodos para añadir elementos a la colección en posiciones específicas o al final. Desde **Java 21**, `List` hereda de `SequencedCollection`, lo que introduce nuevos métodos por defecto como `addFirst` y `addLast`.

### Métodos principales para añadir elementos

```java
boolean add(E e);
```

```java
void add(int index, E element);
```

```java
default void addFirst(E e); // Java 21+
```

```java
default void addLast(E e); // Java 21+
```
---

### Descripción de los métodos

| Método                      | Descripción                                               | Disponible desde |
| --------------------------- | --------------------------------------------------------- | ---------------- |
| `add(E e)`                  | Añade el elemento al **final** de la lista.               | Java 1.2         |
| `add(int index, E element)` | Inserta el elemento en una **posición específica**.       | Java 1.2         |
| `addFirst(E e)`             | Inserta el elemento al **inicio** de la lista.            | Java 21          |
| `addLast(E e)`              | Añade el elemento al **final**, equivalente a `add(E e)`. | Java 21          |

---

### Ejemplo con `add` y `add(index, element)`

```java
List<String> lista = new ArrayList<>();
lista.add("manzana");         // Añade al final (índice 0)
lista.add("naranja");         // Añade al final (índice 1)
lista.add(1, "pera");         // Inserta en el índice 1

System.out.println(lista);    // [manzana, pera, naranja]
```

---

### Ejemplo con `addFirst` y `addLast` (Java 21+)

```java
List<String> lista = new ArrayList<>();
lista.addFirst("primero");    // Inserta al inicio
lista.add("en medio");        // Añade al final
lista.addLast("último");      // También añade al final

System.out.println(lista);    // [primero, en medio, último]
```

> Internamente:
> 
> - `addFirst(e)` llama a `add(0, e)`
>     
> - `addLast(e)` llama a `add(e)`
>     

---

### Compatibilidad

- Si usas una versión anterior a Java 21, **`addFirst` y `addLast` no están disponibles en `List`**.
    
- Antes de Java 21, solo `Deque` (e.g. `LinkedList`) tenía esos métodos.
    
- En Java 21+, puedes usarlos directamente en cualquier implementación de `List` que no los sobrescriba con una excepción (como `List.of()`).
    

---

### Notas

- `add(E e)` y `addLast(E e)` son funcionalmente equivalentes.
    
- `addFirst(E e)` permite una forma más expresiva y semántica de insertar al inicio.
    
- Las nuevas capacidades vienen de que `List` implementa `SequencedCollection` en Java 21.

---

## Método `get` en `List<E>` (y novedades en Java 21+)

La interfaz `List<E>` define métodos para recuperar elementos en posiciones específicas, y desde **Java 21** añade nuevos métodos por defecto para acceder al primer y al último elemento de forma directa.

---

### Métodos principales

```java
E get(int index); 
default E getFirst();   // Java 21+ 
default E getLast();    // Java 21+
```


---

### Descripción de los métodos

|Método|Lo que hace|Comportamiento en casos especiales|Disponible desde|
|---|---|---|---|
|`get(int index)`|Devuelve el elemento que está en la posición `index`.|Si `index < 0` o `index ≥ size()`, lanza `IndexOutOfBoundsException`.|Java 1.2|
|`getFirst()`|Devuelve el primer elemento de la lista.|Si la lista está vacía, lanza `NoSuchElementException`.|Java 21|
|`getLast()`|Devuelve el último elemento de la lista, equivalente a `get(size() - 1)`.|Si la lista está vacía, lanza `NoSuchElementException`.|Java 21|

---

### Ejemplos

```java
List<String> lista = new ArrayList<>(); 
lista.add("A"); 
lista.add("B"); 
lista.add("C");  

// Uso de get(index) 
String segundo = lista.get(1);  // "B"  

// En Java 21+, uso de getFirst y getLast 
String primero = lista.getFirst();  // "A" 
String ultimo = lista.getLast();    // "C"
```


---

### Notas importantes

- `get(int index)` es el método clásico, disponible en todas las versiones modernas de Java.
    
- Los métodos `getFirst()` y `getLast()` fueron añadidos en Java 21 como parte de la interfaz `SequencedCollection`, que List implementa.
    
- Usar `getFirst()` y `getLast()` puede hacer el código más claro, evitando escribir `get(0)` o `get(size() - 1)` explícitamente.
    
- Al igual que con `addFirst/addLast`, si tu código corre en una versión anterior a Java 21, estos métodos no estarán disponibles.

---

## Método `contains` en `List<E>`

El método `contains(Object o)` permite verificar si un elemento está presente en la lista. Esta función forma parte de la interfaz `Collection<E>` y, por lo tanto, está disponible en `List<E>`.

### Firma

```java
boolean contains(Object o);
```

### Descripción

- Devuelve `true` si la lista contiene al menos un elemento `e` tal que `Objects.equals(o, e)`.
    
- Si `o` es `null`, el método puede devolver `true` si algún elemento de la lista es `null` (y la lista permite `null`).
    
- Si la lista no contiene el elemento, devuelve `false`.
    

### Ejemplo de uso

```java
List<String> lista = new ArrayList<>();
lista.add("uno");
lista.add("dos");
lista.add("tres");

boolean tieneDos = lista.contains("dos");     // true
boolean tieneCuatro = lista.contains("cuatro"); // false
```

### Consideraciones

- `contains` realiza una búsqueda **lineal** (itera por los elementos) para encontrar el objeto, lo cual tiene complejidad O(n) en la mayoría de las implementaciones de `List`.
    
- El método `equals` del objeto buscado juega un rol crucial. Para objetos personalizados, si no sobrescribes `equals`/`hashCode`, `contains` podría no comportarse como esperas.
    
- Si la lista contiene `null`, se compara con `o` usando `== null` cuando `o` también sea `null`.

---
## Método `Arrays.asList()`

El método `Arrays.asList()` convierte un arreglo en una lista fija, es decir, una lista cuyo tamaño no puede modificarse. Esto significa que no puedes añadir ni eliminar elementos de la lista, pero sí puedes modificar los elementos existentes.

### Firma

`@SafeVarargs public static <T> List<T> asList(T... a);`

### Descripción

- **Retorno**: Devuelve una lista de tamaño fijo respaldada por el arreglo especificado. Los cambios realizados en el arreglo se reflejarán en la lista y viceversa.
    
- **Modificaciones**: Aunque puedes modificar los elementos de la lista, no puedes cambiar su tamaño (añadir o eliminar elementos). Intentar hacerlo lanzará una excepción `UnsupportedOperationException`.
    
- **Compatibilidad**: Funciona con arreglos de objetos. Para arreglos de tipos primitivos (como `int[]`), debes usar sus clases envolventes correspondientes (`Integer[]`, `Double[]`, etc.) o convertirlos manualmente.
    

### Ejemplo

```java
String[] frutas = {"manzana", "banana", "cereza"}; 
List<String> listaFrutas = Arrays.asList(frutas);  

System.out.println(listaFrutas);  // [manzana, banana, cereza]  

listaFrutas.set(1, "naranja"); 
System.out.println(listaFrutas);  // [manzana, naranja, cereza]
```

### Consideraciones

- **Tamaño fijo**: No puedes añadir ni eliminar elementos de la lista. Intentar hacerlo lanzará una `UnsupportedOperationException`.
    
- **Arreglos primitivos**: Si pasas un arreglo de tipo primitivo (por ejemplo, `int[]`), el método devolverá una lista de un solo elemento que es el arreglo completo. Para obtener una lista de elementos individuales, necesitas usar las clases envolventes correspondientes o convertir el arreglo manualmente.
    
- **Inmutabilidad**: Si deseas una lista inmutable, puedes envolver la lista devuelta por `asList()` con `Collections.unmodifiableList()`.
    

### Alternativas

Si necesitas una lista que permita añadir o eliminar elementos, puedes crear una nueva lista a partir de la lista fija:

```java
List<String> listaModificable = new ArrayList<>(Arrays.asList(frutas));
```

Esto te dará una lista que puedes modificar libremente.

---

## Método `toArray()` en `List<E>`

El método `toArray()` en la interfaz `List<E>` se utiliza para convertir una lista en un arreglo. Existen dos sobrecargas principales de este método:

### 1. `Object[] toArray()`

Devuelve un arreglo de tipo `Object[]` que contiene todos los elementos de la lista en el orden correcto.

**Firma:**

```java
Object[] toArray();
```

**Descripción:**

- **Retorno:** Un arreglo de tipo `Object[]` que contiene todos los elementos de la lista en el orden correcto.
    
- **Uso:** Útil cuando no se necesita un tipo específico para el arreglo resultante.
    

**Ejemplo:**

```java
List<String> lista = new ArrayList<>(); 
lista.add("uno"); 
lista.add("dos"); 
lista.add("tres");  

Object[] arreglo = lista.toArray(); 
System.out.println(Arrays.toString(arreglo));  // Salida: [uno, dos, tres]
```

### 2. `<T> T[] toArray(T[] a)`

Devuelve un arreglo de tipo `T[]` que contiene todos los elementos de la lista en el orden correcto. Si el arreglo proporcionado es lo suficientemente grande, se utiliza; de lo contrario, se crea uno nuevo del mismo tipo.

**Firma:**

```java
<T> T[] toArray(T[] a);
```


**Descripción:**

- **Parámetro:** `T[] a` — Un arreglo de tipo `T[]` que se utiliza para almacenar los elementos de la lista.
    
- **Retorno:** Un arreglo de tipo `T[]` que contiene todos los elementos de la lista en el orden correcto.
    
- **Uso:** Preferido cuando se requiere un arreglo de un tipo específico.
    

**Ejemplo:**

```java
List<String> lista = new ArrayList<>(); 
lista.add("uno"); 
lista.add("dos"); 
lista.add("tres");  

String[] arreglo = lista.toArray(new String[0]); 
System.out.println(Arrays.toString(arreglo));  // Salida: [uno, dos, tres]
```


**Nota:** Utilizar `new String[0]` como argumento es una práctica común para garantizar la creación de un arreglo del tipo adecuado.

---

### Consideraciones Importantes

- **Tipo de Retorno:** La sobrecarga `toArray()` sin parámetros devuelve un arreglo de tipo `Object[]`, lo que puede requerir un casting si se necesita un tipo específico. La sobrecarga `toArray(T[] a)` devuelve un arreglo del tipo especificado, evitando la necesidad de un casting posterior.
    
- **Rendimiento:** Al pasar un arreglo de tamaño cero (`new String[0]`), Java puede optimizar la creación del arreglo resultante. Aunque en versiones anteriores se recomendaba pasar un arreglo del tamaño adecuado, en Java 21+ esta práctica sigue siendo válida y segura.
    
- **Compatibilidad:** Estas sobrecargas están disponibles en todas las versiones modernas de Java, incluyendo Java 21+.

---

## Método `containsAll` en `List<E>`

El método `containsAll(Collection<?> c)` permite verificar si una lista contiene todos los elementos de una colección especificada. Este método forma parte de la interfaz `Collection<E>` y, por lo tanto, está disponible en `List<E>`.

### Firma

`boolean containsAll(Collection<?> c);`

### Descripción

- **Parámetro:** `c` — La colección cuyos elementos se verificarán en la lista.
    
- **Retorno:** `true` si la lista contiene todos los elementos de la colección especificada; `false` en caso contrario.
    
- **Excepciones:**
    
    - `ClassCastException` — Si los tipos de uno o más elementos de la colección especificada no son compatibles con esta lista (opcional).
        
    - `NullPointerException` — Si la colección especificada contiene uno o más elementos `null` y esta lista no permite elementos `null`, o si la colección especificada es `null`.
        

### Ejemplo

```java
import java.util.*;  

public class EjemploContainsAll {     
    public static void main(String[] args) {         
        List<String> lista = new ArrayList<>(Arrays.asList("uno", "dos", "tres"));         
        List<String> subLista = Arrays.asList("uno", "tres");          

        boolean contiene = lista.containsAll(subLista);         
        System.out.println("¿La lista contiene todos los elementos de la sublista? " + contiene);     
    } 
}
```


**Salida:**

`¿La lista contiene todos los elementos de la sublista? true`

### Consideraciones

- **Orden de los elementos:** El método `containsAll` no garantiza que los elementos estén en el mismo orden que en la colección especificada. Solo verifica la presencia de todos los elementos.
    
- **Duplicados:** Si la colección especificada contiene elementos duplicados, `containsAll` devolverá `false` si la lista no contiene al menos tantas ocurrencias del elemento como la colección especificada.
    
- **Rendimiento:** La implementación de `containsAll` puede variar según la implementación específica de `List`. En general, este método tiene una complejidad de tiempo O(n*m), donde n es el tamaño de la lista y m es el tamaño de la colección especificada.

---

## Método `remove` en `List<E>`

El método `remove` en la interfaz `List<E>` se utiliza para eliminar elementos de una lista. Existen dos sobrecargas principales de este método:

### 1. `boolean remove(Object o)`

Elimina la primera aparición del elemento especificado en la lista, si está presente.

**Firma:**

```java
boolean remove(Object o);
```


**Descripción:**

- **Parámetro:** `o` — El elemento que se desea eliminar de la lista.
    
- **Retorno:** `true` si la lista contenía el elemento especificado; `false` en caso contrario.
    
- **Excepciones:**
    
    - `ClassCastException` — Si el tipo del elemento especificado es incompatible con la lista (opcional).
        
    - `NullPointerException` — Si el elemento especificado es `null` y la lista no permite elementos `null` (opcional).
        

**Ejemplo:**

```java
List<String> lista = new ArrayList<>();
lista.add("uno");
lista.add("dos");
lista.add("tres");

boolean eliminado = lista.remove("dos");
System.out.println(eliminado);  // Salida: true
System.out.println(lista);      // Salida: [uno, tres]
```

### 2. `E remove(int index)`

Elimina el elemento en la posición especificada en la lista.

**Firma:**

```java
E remove(int index);
```

**Descripción:**

- **Parámetro:** `index` — El índice del elemento que se desea eliminar.
    
- **Retorno:** El elemento que fue eliminado de la lista.
    
- **Excepciones:**
    
    - `IndexOutOfBoundsException` — Si el índice está fuera del rango de la lista.
        

**Ejemplo:**

```java
List<String> lista = new ArrayList<>();
lista.add("uno");
lista.add("dos");
lista.add("tres");

String eliminado = lista.remove(1);
System.out.println(eliminado);  // Salida: dos
System.out.println(lista);      // Salida: [uno, tres]
```

---

### Consideraciones Importantes

- **Modificación de la lista:** Ambos métodos modifican la lista original. Si se necesita conservar la lista original, se debe crear una copia antes de realizar la eliminación.
    
- **Iteración durante la eliminación:** Al eliminar elementos de una lista mientras se itera sobre ella, es recomendable utilizar un `Iterator` y su método `remove()` para evitar errores concurrentes.
    
- **Listas inmutables:** Si la lista es inmutable (por ejemplo, creada con `List.of()`), llamar a `remove` lanzará una `UnsupportedOperationException`.
    

---

## Método `subList` en `List<E>`

El método `subList(int fromIndex, int toIndex)` permite obtener una vista parcial de una lista, es decir, una sublista que contiene los elementos entre los índices especificados.

### Firma

```java
List<E> subList(int fromIndex, int toIndex);
```

### Descripción

- **Parámetros:**
    
    - `fromIndex`: índice inicial (inclusive) de la sublista.
        
    - `toIndex`: índice final (exclusivo) de la sublista.
        
- **Retorno:** una vista de la porción de la lista entre los índices especificados.
    
- **Excepciones:**
    
    - `IndexOutOfBoundsException`: si `fromIndex` o `toIndex` están fuera del rango válido de la lista o si `fromIndex` es mayor que `toIndex`.
        
- **Comportamiento:**
    
    - La sublista es respaldada por la lista original, lo que significa que los cambios realizados en la sublista se reflejarán en la lista original y viceversa.
        
    - La sublista soporta todas las operaciones opcionales de la lista, incluidas adiciones y eliminaciones, siempre que se realicen dentro del rango de la sublista.  
      Sin embargo, **modificar estructuralmente** la lista original fuera de ese rango invalidará la sublista y lanzará una `ConcurrentModificationException`.
        

### Ejemplo

```java
import java.util.*;  

public class EjemploSubList {     
    public static void main(String[] args) {         
        List<String> lista = new ArrayList<>(Arrays.asList("uno", "dos", "tres", "cuatro", "cinco"));         
        List<String> subLista = lista.subList(1, 4);          

        System.out.println("Sublista: " + subLista);  // Salida: [dos, tres, cuatro]         
        subLista.set(1, "nuevo");         
        System.out.println("Lista original: " + lista);  // Salida: [uno, dos, nuevo, cuatro, cinco]     
    } 
}
```

### Consideraciones

- **Modificaciones estructurales:** Si la lista original se modifica estructuralmente (añadiendo o eliminando elementos) fuera del rango de la sublista, el comportamiento de la sublista se vuelve indefinido. Por lo tanto, es recomendable evitar modificaciones estructurales en la lista original mientras se trabaja con la sublista.
    
- **Uso recomendado:** `subList` es útil cuando se necesita trabajar con una porción específica de una lista sin crear una nueva lista completa, lo que puede ahorrar memoria y mejorar el rendimiento.
    

---

## Modificación de listas durante la iteración en Java

En Java, modificar una lista mientras se itera sobre ella puede llevar a comportamientos inesperados o excepciones. A continuación, se detallan las razones detrás de estos comportamientos y cómo evitarlos.

---

### Uso de `foreach` y `ConcurrentModificationException`

El bucle `foreach` en Java utiliza un iterador implícito para recorrer los elementos de una lista. Si se modifica la lista (por ejemplo, eliminando un elemento) durante la iteración, se puede producir una excepción `ConcurrentModificationException`. Esto ocurre porque el iterador detecta que la estructura de la lista ha cambiado mientras la estaba recorriendo, lo que puede llevar a resultados impredecibles.

**Ejemplo que causa error:**

```java
List<Integer> lista = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer num : lista) {
    if (num == 3) {
        lista.remove(num); // Lanza ConcurrentModificationException
    }
}

```

**Explicación:**

- El bucle `foreach` utiliza un iterador implícito.
    
- Al eliminar un elemento de la lista durante la iteración, se modifica la estructura interna de la lista.
    
- El iterador detecta este cambio y lanza una `ConcurrentModificationException` para evitar comportamientos indeterminados.
    

---

### Uso de `Iterator` para eliminar elementos de forma segura

Para eliminar elementos de una lista durante la iteración sin causar excepciones, se debe utilizar un `Iterator` explícito. El método `remove()` del `Iterator` permite eliminar de forma segura el último elemento retornado por el iterador.

**Ejemplo correcto:**

```java
List<Integer> lista = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Iterator<Integer> it = lista.iterator();
while (it.hasNext()) {
    Integer num = it.next();
    if (num == 3) {
        it.remove(); // Elimina el elemento de forma segura
    }
}
```

**Explicación:**

- Se crea un `Iterator` explícito para la lista.
    
- Se recorre la lista utilizando el `Iterator`.
    
- Si se cumple la condición (en este caso, si el número es 3), se elimina el elemento utilizando `it.remove()`.
    
- Este enfoque evita la `ConcurrentModificationException` porque la modificación se realiza a través del `Iterator`.
    

---

### Eliminación de elementos consecutivos con un bucle `for` tradicional

Al utilizar un bucle `for` tradicional con un índice para recorrer una lista y eliminar elementos, es posible que no se eliminen todos los elementos consecutivos que cumplen una condición. Esto se debe a que, al eliminar un elemento, los elementos posteriores se desplazan hacia la izquierda, lo que puede hacer que se omitan elementos.

**Ejemplo que omite elementos:**

```java
List<Integer> lista = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (int i = 0; i < lista.size(); i++) {
    if (lista.get(i) == 3) {
        lista.remove(i); // Elimina el elemento en la posición i
    }
}
```


**Explicación:**

- Al eliminar un elemento en la posición `i`, los elementos posteriores se desplazan hacia la izquierda.
    
- El índice `i` se incrementa en cada iteración, lo que puede hacer que se salten elementos que han sido desplazados a la posición `i`.
    
- Como resultado, no se eliminan todos los elementos que cumplen la condición.
    

**Solución:**

Para evitar este problema, se puede iterar sobre la lista en orden inverso. De esta manera, los elementos que se eliminan no afectan a los elementos que aún no se han procesado.

**Ejemplo con iteración inversa:**

```java
List<Integer> lista = new ArrayList<>(Arrays.asList(1, 2, 3, 3, 4, 5));
for (int i = lista.size() - 1; i >= 0; i--) {
    if (lista.get(i) == 3) {
        lista.remove(i); // Elimina el elemento en la posición i
    }
}
```

**Explicación:**

- Se recorre la lista desde el último elemento hacia el primero.
    
- Al eliminar un elemento, los elementos anteriores no se ven afectados, ya que aún no han sido procesados.
    
- Este enfoque asegura que todos los elementos que cumplen la condición sean eliminados correctamente.

---

## Método `removeAll` en `List<E>` para eliminar elementos que cumplen una condición

El método `removeAll(Collection<?> c)` de la interfaz `List<E>` se utiliza para eliminar de la lista todos los elementos que están contenidos en la colección especificada. Este enfoque es útil cuando se desea eliminar múltiples elementos que cumplen una condición específica.

### Firma

`boolean removeAll(Collection<?> c);`

### Descripción

- **Parámetros:**
    
    - `c`: colección que contiene los elementos que se desean eliminar de la lista.
        
- **Valor de retorno:**
    
    - `true` si la lista cambió como resultado de la llamada.
        
    - `false` si la lista no cambió.
        
- **Excepciones:**
    
    - `NullPointerException`: si la colección especificada es nula o si la lista contiene elementos `null` y la colección no permite elementos `null`.
        
    - `ClassCastException`: si la clase de un elemento de la lista es incompatible con la colección especificada.
        

### Ejemplo de uso

Considerando una clase `Alumno` con un método `getNota()` que devuelve la nota del alumno:

```java
import java.util.*;

class Alumno {
    private String nombre;
    private double nota;

    public Alumno(String nombre, double nota) {
        this.nombre = nombre;
        this.nota = nota;
    }

    public double getNota() {
        return nota;
    }

    @Override
    public String toString() {
        return nombre + ": " + nota;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        List<Alumno> alumnos = new ArrayList<>();
        alumnos.add(new Alumno("Juan", 4.5));
        alumnos.add(new Alumno("Ana", 6.0));
        alumnos.add(new Alumno("Luis", 3.8));
        alumnos.add(new Alumno("Marta", 7.2));

        // Crear una lista con los alumnos suspensos (nota < 5)
        List<Alumno> suspensos = new ArrayList<>();
        for (Alumno alumno : alumnos) {
            if (alumno.getNota() < 5) {
                suspensos.add(alumno);
            }
        }

        // Eliminar los alumnos suspensos de la lista original
        alumnos.removeAll(suspensos);

        // Imprimir la lista de alumnos restantes
        System.out.println("Alumnos aprobados:");
        for (Alumno alumno : alumnos) {
            System.out.println(alumno);
        }
    }
}
```

**Salida esperada:**

```java
Alumnos aprobados: Ana: 6.0 Marta: 7.2
```

### Consideraciones

- **Consideración real:** `removeAll` modifica estructuralmente la lista al eliminar todos los elementos contenidos en la colección especificada. Las referencias externas a la lista verán reflejados esos cambios.
    
- **Uso recomendado:** `removeAll` es útil cuando se necesita eliminar múltiples elementos de una lista que cumplen una condición específica, y se dispone de una colección que contiene esos elementos.

---

## NaN in Java

In Java, **NaN** stands for **"Not-a-Number"**. It is a special constant defined in the `Float` and `Double` classes that represents a value that does not represent a valid number, typically resulting from undefined or unrepresentable mathematical operations.

### Key points about NaN in Java:

- NaN is a **double** or **float** value that results from operations like `0.0/0.0`, `Math.sqrt(-1)`, or `Double.parseDouble("abc")` (which throws an exception, but you can get NaN in other cases).
    
- It is part of the IEEE 754 floating-point standard.
    
- NaN is **not equal to any value, including itself**. That means:
    

```java
double nan = Double.NaN;
System.out.println(nan == nan);  // false
System.out.println(Double.isNaN(nan));  // true
```

### How to check if a number is NaN:

Use `Double.isNaN(value)` or `Float.isNaN(value)`.

### Example:

```java
public class NaNExample {
    public static void main(String[] args) {
        double a = 0.0 / 0.0;  // Produces NaN
        System.out.println("a is NaN: " + Double.isNaN(a));  // true

        double b = Math.sqrt(-1);  // Also NaN
        System.out.println("b is NaN: " + Double.isNaN(b));  // true

        double c = 5.0;
        System.out.println("c is NaN: " + Double.isNaN(c));  // false
    }
}
```

---

## Excepción `ConcurrentModificationException`

La excepción `ConcurrentModificationException` se lanza cuando se modifica una colección mientras se está iterando sobre ella de forma que no está permitida.

---

### ¿Cuándo ocurre?

- Cuando se modifica una colección (por ejemplo, una `ArrayList`) directamente dentro de un bucle `for-each` o con un iterador, pero sin usar los métodos seguros de eliminación.
    
- Por ejemplo, eliminar elementos directamente con `list.remove(element)` dentro de un `for-each` provoca esta excepción.
    

---

### Ejemplo problemático

```java
List<String> lista = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String s : lista) {
    if (s.equals("B")) {
        lista.remove(s);  // Esto lanzará ConcurrentModificationException
    }
}
```

---

### Cómo evitarla

#### 1. Usar un `Iterator` y su método `remove()`

```java
Iterator<String> it = lista.iterator();
while (it.hasNext()) {
    String s = it.next();
    if (s.equals("B")) {
        it.remove();  // Eliminación segura durante la iteración
    }
}
```

#### 2. Usar el método `removeIf` (Java 8+)

```java
lista.removeIf(s -> s.equals("B"));
```

---

### Consideraciones

- Modificar la colección directamente durante una iteración que no soporte cambios concurrentes genera esta excepción.
    
- Utilizar los métodos provistos (`Iterator.remove()`, `removeIf`) garantiza una modificación segura.
    
- En colecciones concurrentes (ejemplo: `CopyOnWriteArrayList`) la excepción no ocurre al modificar durante la iteración.

---

## `CopyOnWriteArrayList<E>` y el método `remove()`

`CopyOnWriteArrayList` es una implementación de la interfaz `List` que es **segura para concurrencia** en entornos multihilo.

### Características principales

- Internamente, cada vez que se modifica (añadir, eliminar, etc.), se crea una **nueva copia** del arreglo interno.
- Esto permite que los iteradores y bucles puedan recorrer la lista sin lanzar `ConcurrentModificationException`, ya que trabajan sobre una copia inmutable.
- Es ideal para colecciones donde las operaciones de lectura son mucho más frecuentes que las modificaciones.

### Comportamiento del método `remove()`

- Cuando se llama a `remove()` en un `CopyOnWriteArrayList`, se crea una copia nueva del arreglo sin el elemento eliminado.
- Las iteraciones que estén en curso no se ven afectadas por esta modificación y no lanzan excepción.
- Debido a la copia de datos, las operaciones de modificación (`remove`, `add`, etc.) son más costosas en términos de rendimiento y memoria.

### Ejemplo

```java
List<String> lista = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));

for (String s : lista) {
    if (s.equals("B")) {
        lista.remove(s);  // No lanza ConcurrentModificationException
    }
}

System.out.println(lista); // Salida: [A, C]
```

### Consideraciones

- No usar en escenarios con muchas modificaciones frecuentes debido al coste de crear copias.
    
- Excelente para escenarios de lectura concurrente con pocas modificaciones.
