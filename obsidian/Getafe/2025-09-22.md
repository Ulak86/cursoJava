
## Repaso

Una clase hija hereda todos los atributos no privados de la clase padre.

La sobreescritura se aplica en los métodos heredados en la clase hija cuando modificamos la implementación del método de la clase padre.

Hay 2 metodos de sobreescritura:
- Sobreescritura completa.
- Sobreescritura parcial, extendiendo la funcionalidad. Se usa la expresión super.nombreDeMetodo dentro de la propia declaración del mismo 

Si la clase padre tiene un constructor en lugar del vacío y una clase hija que no tiene un constructor, no se puede invocar al constructor vacío en la clase hija:

- Si **una clase hija no define ningún constructor**, el compilador **automáticamente agrega un constructor por defecto (vacío)** que **invoca al constructor vacío de la clase padre** mediante `super()`.    
- Pero si **la clase padre no tiene un constructor vacío**, el compilador **no puede generar automáticamente el constructor para la hija**, y **da un error de compilación**.
- Si la clase padre **no tiene constructor sin parámetros**, **la clase hija debe declarar un constructor** y **llamar explícitamente a uno de los constructores del padre usando `super(...)`**.

Todos los constructores llaman implícitamente (o explícitamente si usas super) al constructor vacío de la clase Object. 

## toString()

Método de la clase Object.

En default muestra la posición de memoria de un objeto y esta es su declaración en object:

```java
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

En la practica, se sobrescribe para las clases que lo usan.

## Atajos

Ctrl + Shift + T -> En Eclipse Open Type, sirve para abrir declaraciones de clases.

## ¿Qué implica que una variable sea del tipo de la clase padre?

Cuando declaras una variable con el tipo de la clase padre, pero le asignas una instancia de una subclase, estás aplicando uno de los principios fundamentales de la programación orientada a objetos: el polimorfismo.

A continuación se detallan las implicaciones principales:

---

### 1. Solo puedes acceder a los miembros visibles en la clase padre

Aunque el objeto real sea de la subclase, si la variable es del tipo padre, solo puedes llamar directamente a los métodos o atributos que estén definidos en la clase padre. Los métodos y atributos específicos de la subclase no están disponibles a menos que hagas un cast.

Ejemplo:

```java
Padre obj = new Hija();
obj.metodoDelPadre();      // Permitido
obj.metodoSoloDeHija();    // Error de compilación
```

---

### 2. Se ejecutan los métodos sobrescritos de la subclase

Si un método de la clase padre fue sobrescrito en la subclase, entonces, aunque accedas al objeto a través de una variable de tipo padre, se ejecutará la versión de la subclase. Esto se conoce como polimorfismo dinámico.

Ejemplo:

```java
class Padre {
    void saludar() {
        System.out.println("Hola desde Padre");
    }
}

class Hija extends Padre {
    @Override
    void saludar() {
        System.out.println("Hola desde Hija");
    }
}

Padre obj = new Hija();
obj.saludar();  // Imprime: Hola desde Hija
```


---

### 3. Permite programación más flexible

Este enfoque permite escribir código más genérico y reutilizable. Por ejemplo, puedes tener una lista de objetos del tipo padre y agregar instancias de diferentes subclases. También puedes pasar subclases como argumentos a métodos que reciben el tipo padre.

Ejemplo:

```java
void procesar(Padre p) {
    p.saludar();
}

procesar(new Hija());
procesar(new OtraSubclase());
```

---

### 4. Necesitas hacer cast para acceder a métodos específicos de la subclase

Si necesitas usar un método que solo existe en la subclase, debes convertir explícitamente (castear) la variable al tipo de la subclase.

Ejemplo:

```java
Padre obj = new Hija();

if (obj instanceof Hija) {
    ((Hija) obj).metodoSoloDeHija();
}
```


---

### Resumen

- Una variable del tipo padre solo puede acceder directamente a métodos definidos en la clase padre.
    
- Si un método es sobrescrito, se ejecuta la versión correspondiente a la instancia real del objeto, no al tipo de la variable.
    
- Se logra polimorfismo, lo que permite trabajar con distintas subclases de forma uniforme.
    
- Para acceder a funcionalidades propias de la subclase, es necesario hacer un cast explícito.

### Notas

No puedo hacer:

```java
Madre m = new Hija();   // ✓ permitido (toda Hija es una Madre)
Hija h = new Hija();    // ✓ permitido
h = m;                  // ✗ error: no toda Madre es una Hija
```

**Razón:**  
Toda Hija es Madre, pero no toda Madre es Hija.  


## `getClass()`

`getClass()` es un método de la clase `Object` que devuelve en tiempo de ejecución el **objeto Class** que representa la clase real del objeto.

En resumen:

- Permite saber la clase exacta a la que pertenece un objeto.
    
- Es útil para comparar tipos o para reflexión.
    
- No depende del tipo de la referencia, sino de la instancia real.
    

Ejemplo:

```java
Object obj = new String("hola");
System.out.println(obj.getClass());  // Imprime: class java.lang.String
```


---

### Uso de `getClass()` con reflexión

`getClass()` devuelve un objeto `Class<?>` que representa la clase real del objeto. A partir de ese objeto puedes:

- Obtener el nombre de la clase.
    
- Listar sus métodos, campos y constructores.
    
- Crear nuevas instancias dinámicamente.
    
- Consultar anotaciones, modificadores, etc.
    

---

#### Ejemplo básico:

```java
Object obj = new String("hola");
Class<?> clase = obj.getClass();

System.out.println("Nombre clase: " + clase.getName());  
// java.lang.String  

// Listar métodos
for (Method metodo : clase.getDeclaredMethods()) {
    System.out.println(metodo.getName());
}
```


---

#### Para qué sirve la reflexión con `getClass()`

- Frameworks (como Spring, Hibernate) usan reflexión para inspeccionar objetos en tiempo de ejecución.
    
- Permite implementar funciones genéricas, como serialización, copia de objetos, pruebas, etc.
    
- Puedes invocar métodos o acceder a campos sin conocer la clase en tiempo de compilación.



## `instanceof`

`instanceof` es un operador que se usa para **verificar en tiempo de ejecución si un objeto es instancia de una clase o implementa una interfaz determinada**.

---

### ¿Cómo funciona?

```java
if (obj instanceof MiClase) {
    // Aquí sabemos que obj es una instancia de MiClase o una subclase
}
```

- Devuelve `true` si el objeto es una instancia de la clase indicada o una subclase.
    
- Devuelve `false` si no lo es o si el objeto es `null`.
    

---

### Ejemplo:

```java
Object obj = new String("Hola");

if (obj instanceof String) {
    System.out.println("Es un String");
}

if (obj instanceof Object) {
    System.out.println("Es un Object");
}
```

**Salida:**

```
Es un String
Es un Object
```


---

### Usos comunes:

- Evitar errores de casteo (`ClassCastException`) verificando el tipo antes de castear.
    
- Lógica condicional según el tipo real del objeto.

## Cast de variables de tipo objeto

Cuando tienes una variable declarada con un tipo de clase (generalmente una superclase o interfaz), pero sabes que la instancia es de una subclase más específica, puedes convertir (castear) esa variable para acceder a métodos o atributos propios de la subclase.

---

### Sintaxis del cast explícito

```java
SuperClase obj = new SubClase();
SubClase subObj = (SubClase) obj; // Cast explícito
```

---

### ¿Por qué hacer cast?

- Para acceder a métodos o atributos que no están definidos en la clase de la variable, pero sí en la subclase.
    
- Para evitar errores de compilación al llamar a esos métodos.
    

---

### Ejemplo:

```java
class Animal {
    void comer() { System.out.println("Comer"); }
}

class Perro extends Animal {
    void ladrar() { System.out.println("Ladrar"); }
}

Animal a = new Perro();
a.comer();  // OK

// a.ladrar();  // ERROR: método no visible para tipo Animal

// Para llamar ladrar():
if (a instanceof Perro) {
    ((Perro) a).ladrar();  // Cast para usar método específico
}
```

---

### Riesgo

Si el objeto **no es realmente** una instancia de la subclase, el cast lanza una excepción en tiempo de ejecución:

```java
Animal a = new Animal();
Perro p = (Perro) a;  // ClassCastException en tiempo de ejecución
```

---

Ejemplo completo con manejo seguro de cast para evitar errores:

````java
class Animal {
    void comer() {
        System.out.println("Animal comiendo");
    }
}

class Perro extends Animal {
    void ladrar() {
        System.out.println("Perro ladrando");
    }
}

class Gato extends Animal {
    void maullar() {
        System.out.println("Gato maullando");
    }
}

public class TestCast {
    public static void main(String[] args) {
        Animal animal1 = new Perro();
        Animal animal2 = new Gato();
        Animal animal3 = new Animal();

        llamarMetodoEspecifico(animal1);
        llamarMetodoEspecifico(animal2);
        llamarMetodoEspecifico(animal3);
    }

    static void llamarMetodoEspecifico(Animal a) {
        a.comer();

        if (a instanceof Perro) {
            ((Perro) a).ladrar();
        } else if (a instanceof Gato) {
            ((Gato) a).maullar();
        } else {
            System.out.println("No es ni Perro ni Gato");
        }
    }
}

````

### Qué pasa aquí:

- Declaramos variables del tipo `Animal` que contienen instancias de `Perro`, `Gato` y `Animal`.
    
- En el método `llamarMetodoEspecifico` usamos `instanceof` para saber el tipo real.
    
- Solo hacemos el cast si sabemos que es seguro.
    
- Evitamos el error `ClassCastException`.
## @Anotaciones 

### ¿Qué son las anotaciones en Java?

Las **anotaciones** en Java son una forma de agregar **metadatos** al código fuente. Proporcionan información adicional que puede ser utilizada por el compilador, herramientas o incluso en tiempo de ejecución mediante reflexión.

Se escriben anteponiendo `@` al nombre, por ejemplo: `@Override`, `@Deprecated`, `@Test`.

---

### Tipos de anotaciones según su uso o momento de procesamiento

#### 1. Anotaciones en tiempo de compilación

Se procesan durante la **compilación** del código. El compilador puede utilizarlas para emitir advertencias, errores o generar código adicional.

**Ejemplos comunes:**

- `@Override`
    
- `@Deprecated`
    
- `@SuppressWarnings`
    

**Para qué sirven:**

- Validan que ciertos métodos estén correctamente sobrescritos.
    
- Ocultan advertencias del compilador.
    
- Informan que una clase o método está obsoleto.
    

**Ejemplo:**

`@Override public String toString() {     return "Hola"; }`

Si `toString()` no estuviera sobrescribiendo un método real, el compilador lanzaría un error.

---

#### 2. Anotaciones en tiempo de ejecución

Estas anotaciones permanecen en el **bytecode** y pueden ser leídas durante la **ejecución** del programa usando reflexión.

**Ejemplos comunes:**

- `@Entity`, `@Id`, `@Column` (JPA)
    
- `@RequestMapping`, `@RestController` (Spring)
    
- `@Inject`, `@Autowired` (inyección de dependencias)
    

**Para qué sirven:**

- Configurar cómo funcionan frameworks como Spring o Hibernate.
    
- Mapear clases a tablas de base de datos.
    
- Inyectar dependencias automáticamente.
    

**Ejemplo:**

`@RestController @RequestMapping("/api") public class MiControlador { }`

En este caso, Spring procesa estas anotaciones en tiempo de ejecución para exponer un endpoint HTTP.

---

#### 3. Anotaciones para pruebas

Se utilizan en frameworks de testing como JUnit o TestNG para definir métodos de prueba y controlar su ejecución.

**Ejemplos comunes:**

- `@Test`
    
- `@BeforeEach`, `@AfterEach`
    
- `@BeforeAll`, `@AfterAll`
    
- `@DisplayName`
    

**Para qué sirven:**

- Marcar métodos como pruebas.
    
- Ejecutar acciones antes o después de cada prueba.
    
- Documentar o describir pruebas.
    

**Ejemplo con JUnit 5:**

`import org.junit.jupiter.api.*;  class CalculadoraTest {      @BeforeEach     void setUp() {         // Se ejecuta antes de cada test     }      @Test     void testSuma() {         Assertions.assertEquals(4, 2 + 2);     } }`

Estas anotaciones son interpretadas por JUnit en tiempo de ejecución.

---

### ¿Cómo se clasifican internamente?

Las anotaciones pueden definirse con diferentes niveles de retención usando `@Retention`, lo cual indica hasta cuándo estarán disponibles.

|Tipo de retención|Se procesa en...|Uso común|
|---|---|---|
|`SOURCE`|Solo durante la compilación|`@Override`, `@SuppressWarnings`|
|`CLASS` (por defecto)|Compilación y bytecode|Anotaciones técnicas no visibles en ejecución|
|`RUNTIME`|Tiempo de ejecución (reflexión)|`@Entity`, `@Test`, `@Autowired`|

---

#### Resumen

| Tipo de anotación | Se usa para...                      | Ejemplos                            |
| ----------------- | ----------------------------------- | ----------------------------------- |
| En compilación    | Validar o generar código            | `@Override`, `@SuppressWarnings`    |
| En ejecución      | Configurar frameworks dinámicamente | `@Entity`, `@RestController`        |
| Para pruebas      | Definir métodos y ciclos de testing | `@Test`, `@BeforeEach`, `@AfterAll` |

---