## BBDD

### Ejercicio 1 bis

  

=============================================

  

Crear la tabla usuarios:

  

Columnas:

id: Entero, clave primaria y autoincrementable.

nombre: Cadena de caracteres (VARCHAR(50)), no nula.

email: Cadena de caracteres (VARCHAR(100)), no nula y única.

fecha_registro: Fecha, con valor por defecto (Fecha actual)

  

```sql

CREATE TABLE tb_usuarios (

id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

nombre VARCHAR(50) NOT NULL,

email VARCHAR(50) NOT NULL UNIQUE,

fecha_registro DATE DEFAULT SYSDATE

);

```

Modificar la tabla para añadir una columna: Agregar la columna telefono de tipo VARCHAR(15) que permita valores nulos.

  

```sql

ALTER TABLE tb_usuarios ADD telefono VARCHAR(15);

```

  

Modificar el tipo de datos de la columna nombre: Cambiar la definición de nombre a VARCHAR(100).

  

```sql

ALTER TABLE tb_usuarios MODIFY nombre VARCHAR(100);

```

  

  

### Ejercicio 2

  

Ejercicio 2

  

=============================================

  

1. Creación de la tabla productos

  

Requisitos:

  

- Campos y restricciones:

- id: Entero, clave primaria y autoincrementable.

- nombre: Cadena de caracteres (VARCHAR(100)), no nulo.

- descripcion: Texto (TEXT), puede ser nulo.

- precio: Número decimal (DECIMAL(8,2)), no nulo y debe ser mayor o igual a 0.

- stock: Entero, no nulo y con valor por defecto 0.

- fecha_registro: Fecha y hora (DATETIME), con valor por defecto la fecha y hora actual.

- descuento: Número entero, que representa el porcentaje de descuento (entre 0 y 100). (Se usará una restricción CHECK para validar este rango.)

- estado: Cadena de caracteres (ENUM) que solo puede tener los valores 'activo' o 'inactivo', con valor por defecto 'activo'.

  

```sql

CREATE TABLE tb_productos (

id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,

nombre VARCHAR(100) NOT NULL,

descripcion CLOB,

precio NUMBER(8,2) DEFAULT 0 NOT NULL CHECK (precio >= 0),

stock NUMBER(10,0) DEFAULT 0 NOT NULL,

fecha_registro DATE DEFAULT SYSDATE,

descuento NUMBER(3,0) CHECK (descuento >= 0 AND descuento <= 100),

estado VARCHAR(8) DEFAULT 'activo' CHECK (estado IN ('activo', 'inactivo'))

);

```

  

> Cree un **CLOB** porque no me permitía crear un TEXT en description e hice ese check ene estado porque no me permite crear ENUM

  

2. Modificación de la tabla productos

- a) Añadir nuevas columnas

- Agregar la columna categoria:

- Tipo VARCHAR(50), no nulo.

- Agregar la columna proveedor:

- Tipo VARCHAR(100), que permita nulos.

```sql

ALTER TABLE tb_productos

ADD(

categogoria VARCHAR(50) NOT NULL,

proveedor VARCHAR(100)

);

```

  

- b) Modificar el tipo de datos de la columna descripcion

- Cambiar el tipo de datos de descripcion de TEXT a VARCHAR(500) para limitar la longitud a 500 caracteres.

  

Intentar

  

```sql

ALTER TABLE tb_productos MODIFY descripcion VARCHAR(500);

```

  

dio el siguiente error

  

```bash

Error starting at line : 1 in command -

ALTER TABLE tb_productos MODIFY descripcion VARCHAR(500)

Error report -

ORA-22859: invalid modification of columns

```

  

> You defined `descripcion` as a **CLOB** (large object) when you created the table.

> Now you’re trying to `MODIFY` it into a `VARCHAR(500)`, but **Oracle does not allow converting a LOB column (CLOB, BLOB, etc.) to a scalar type like VARCHAR**

  

asi que elimine la columna y la volvi a crear (si tuviera contenido la habria tenido que copiar primero pensar en como conservar el ID):

  

```sql

ALTER TABLE tb_productos

DROP COLUMN descripcion;

```

  

```sql

ALTER TABLE tb_productos

ADD descripcion VARCHAR(500);

```

  

3. Eliminación de la tabla productos

Una vez realizados los ejercicios y pruebas, se eliminará la tabla.

```sql

DROP TABLE tb_productos

```

## PPOO

El profesor repasó lo siguientes conceptos al explicar el ejercicio del hospital.

### 1

> En Java, cuando una variable de tipo de clase padre hace referencia a un objeto de una clase hija, se ejecuta el método sobrescrito de la clase hija gracias al **polimorfismo** y al mecanismo de **despacho dinámico**, que determina en tiempo de ejecución qué implementación del método debe invocarse.

```java
class Animal {
    void hacerSonido() {
        System.out.println("Sonido genérico de animal");
    }
}

class Perro extends Animal {
    @Override
    void hacerSonido() {
        System.out.println("Guau guau");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Perro();  // Referencia de tipo padre apuntando a un objeto hijo
        miAnimal.hacerSonido();         // Se ejecuta el método de la clase Perro
    }
}
```

Output

```nginx
Guau guau
```

### 2

> [!note] Declaración y asignación directa con evaluación lógica

 1. Declaración y asignación directa con evaluación lógica:

```java
boolean esMayor = (edad > 18);
```

2. Declarar con valor inicial `false` y asignar después con el mismo condicional:

```java
boolean esMayor = false;
if (edad > 18) {
    esMayor = true;
}
```

### 3
 
 Ha explicado la importancia de pensar teniendo en cuenta los pasos por referencia. Usando como ejemplo mi método de pasar consulta que ponía la variable paciente que usaba el método a null pero seguía habiendo pacientes en la sala de espera.


### Interfaces

Las **interfaces** en Java se declaran para **obligar a las clases que las implementen** a definir los métodos que la interfaz especifica.

Solo contienen **métodos abstractos** (hasta Java 7) y **variables estáticas y finales** (constantes).  
Desde Java 8, las interfaces también pueden contener:

- **métodos `default`** (con implementación por defecto)
    
- **métodos `static`** con implementación
    
- **métodos `private`** (a partir de Java 9) para uso interno en la interfaz.
    

Sin embargo, todas las variables definidas en una interfaz son **implícitamente `public static final`**, aunque no se especifique.

Una clase que implementa una interfaz está obligada a sobrescribir (implementar) todos los métodos abstractos que declara la interfaz, a menos que la clase sea **abstracta**.

Es una **convención** en Java escribir variables constantes (`final static`) en mayúsculas con guiones bajos para distinguirlas fácilmente. En las **interfaces**, las variables son **implícitamente `public static final`**, por lo que también siguen esta convención. Eclipse, además, suele aplicar cursiva para marcar que son constantes.

Ejemplo:

```java
interface Configuracion {
    // Variable implícitamente public static final
    int MAX_INTENTOS = 5;
    String MENSAJE_ERROR = "Error crítico";
}

```

Sintaxis básica para que una interfaz herede de otra en Java:

```java
interface InterfazPadre {
    void metodoA();
}

interface InterfazHija extends InterfazPadre {
    void metodoB();
}
```

Una interfaz puede heredar de **una o varias** interfaces usando `extends` y separándolas por comas:

```java
interface InterfazHija extends InterfazPadre1, InterfazPadre2 {
    void metodoB();
}
```

A efectos prácticos, una **interfaz** se utiliza para declarar funcionalidades comunes a diferentes clases, permitiendo que cada clase las implemente según su propia lógica. Por ejemplo, los métodos `encender` y `apagar` pueden ser comunes tanto en coches como en ordenadores, pero cada uno tendrá una implementación diferente en cada clase.

Una clase que implementa una interfaz puede ser referenciada mediante una variable de tipo interfaz. Es decir, es posible declarar una variable cuyo tipo sea la interfaz y que apunte a una instancia de esa clase.

Cuando una clase **implementa una interfaz**, esa clase **es un tipo de esa interfaz**. Por lo tanto, puedes hacer esto:

```java
Interfaz miVariable = new MiClaseQueImplementaInterfaz();
```

```java
interface Vehiculo {
    void arrancar();
}

class Coche implements Vehiculo {
    @Override
    public void arrancar() {
        System.out.println("El coche ha arrancado");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehiculo miVehiculo = new Coche();  // Variable de tipo interfaz que referencia una instancia de Coche
        miVehiculo.arrancar();               // Llama al método implementado en Coche
    }
}
```

Entonces, por ejemplo, podemos construir un array de una interfaz que implementen clases diferentes que no heredan de una clase común conteniendo instancias de estas clases. 

